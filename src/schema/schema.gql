# Fields that are only safe within the native app environment and are blocked
# from execution in the hosted / web environment.
directive @insecure on FIELD_DEFINITION
directive @client on FIELD
directive @authenticated on FIELD

directive @sign(
  source: String = "unsigned"
  target: String = "signed"
) on FIELD

directive @account(
  arg: String = "from"
) on FIELD

scalar DateTime

enum ExchangeEnum {
  RADAR_RELAY
  OASIS_DEX
  ERC_DEX
  KYBER_NETWORK
}

enum SymbolEnum {
  WETH
  ETH
  MLN
}

enum FundSetupStepEnum {
  CREATE_ACCOUNTING
  CREATE_FEE_MANAGER
  CREATE_PARTICIPATION
  CREATE_POLICY_MANAGER
  CREATE_SHARES
  CREATE_TRADING
  CREATE_VAULT
}

type Price {
  base: Quantity
  quote: Quantity
}

type Quantity {
  token: Token
  quantity: String
}

type Token {
  symbol: String
  decimals: Int
  address: String
}

type Ranking {
  rank: Int
  address: String
  name: String
  inception: DateTime
  fund: Fund
  sharePrice: String
}

type Settings {
  accountingAddress: String
  feeManagerAddress: String
  participationAddress: String
  policyManagerAddress: String
  priceSourceAddress: String
  registrarAddress: String
  sharesAddress: String
  tradingAddress: String
  vaultAddress: String
  versionAddress: String
}

type Fund {
  rank: Int
  address: String
  name: String
  inception: DateTime
  gav: Quantity
  nav: Quantity
  owner: String
  modules: [String]
  settings: Settings
  holdings: [Holding]
  sharePrice: Quantity
  totalSupply: Quantity
  personalStake(investor: String): Quantity
  managementReward: Quantity
  performanceReward: Quantity
  unclaimedFees: Quantity
  feesShareQuantity: Quantity
  isShutdown: Boolean
  openOrders(
    offset: Int = 0
    limit: Int = 10
  ): [Order]
  recentTrades(
    base: String!
    quote: String!
    offset: Int = 0
    limit: Int = 10
  ): [Trade]
}

type Holding {
  balance: Quantity!
  price: Price!
  fraction: String!
}

type Trade {
  price: Price
  quantity: Quantity
  timestamp: String
  type: String
}

interface Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: Quantity!
  sell: Quantity!
  price: Price!
  exchangeContractAddress: String
  exchange: String
}

type ZeroExOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: Quantity!
  sell: Quantity!
  price: Price!
  expiration: String
  salt: String!
  makerFee: String!
  takerFee: String!
  signature: Signature
  feeRecipient: String
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type OasisDexOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: Quantity!
  sell: Quantity!
  price: Price!
  id: String!
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type Orderbook {
  allOrders: [Order]
  sellEntries: [OrderbookEntry]
  buyEntries: [OrderbookEntry]
  totalBuyVolume: String
  totalSellVolume: String
}

type OrderbookEntry {
  volume: String
  order: Order
}

type Signature {
  r: String!
  s: String!
  v: Int!
}

type ExchangeConfig {
  adapterAddress: String!
  exchangeAddress: String!
  takesCustody: Boolean!
}

type AdapterAddresses {
  kyberAdapter: String!
  matchingMarketAdapter: String!
  zeroExAdapter: String!
}

type PolicyAddresses {
  priceTolerance: String!
  userWhitelist: String!
}

type FactoryAddresses {
  accountingFactory: String!
  feeManagerFactory: String!
  participationFactory: String!
  policyManagerFactory: String!
  sharesFactory: String!
  tradingFactory: String!
  vaultFactory: String!
}

type ThirdPartyContracts {
  exchanges: [ExchangeConfig]!
  tokens: [Token]!
}

type MelonContracts {
  priceSource: String!
  adapters: AdapterAddresses!
  policies: PolicyAddresses!
  engine: String!
  registry: String!
  version: String!
  ranking: String!
}

type Deployment {
  melonContracts: MelonContracts!
  thirdPartyContracts: ThirdPartyContracts!
  version: String
  ranking: String
  tokens: [Token]
}

type UnsignedTransaction {
  data: String
  from: String
  gas: String
  gasPrice: String
  to: String
  value: String
}

input UnsignedTransactionInput {
  data: String
  from: String
  gas: String
  gasPrice: String
  to: String
  value: String
}

type Query {
  defaultAccount: String @insecure
  allAccounts: [String] @insecure
  hasStoredWallet: Boolean @insecure

  "Fetch the associated fund of an account."
  associatedFund(
    "The address of the account to load the fund for."
    manager: String
  ): String

  "Loads the current step for fund creation for a fund manager address."
  stepFor(
    "The address of the fund manager."
    manager: String
  ): Int

  "Loads a fund by its name."
  fundByName(
    "The name of the fund to load."
    name: String!
  ): Fund

  network: String
  currentBlock: String
  nodeSynced: Boolean
  priceFeedUp: Boolean
  peerCount: String
  contractDeployment: Deployment
  totalFunds: Int
  balance(symbol: SymbolEnum!, address: String): Quantity
  fund(address: String!): Fund
  rankings: [Ranking]
}

type Mutation {
  cancelOpenOrder(
    orderId: String!
    fundAddress: String!
    makerAssetSymbol: String!
    takerAssetSymbol: String!
  ): [Order]

  # TODO: Give more fund configuration options: Policies, pricefeed, ...
  """
  Estimates the number of gas units required for the "beginSetup" transaction.
  """
  estimateFundSetupBegin(
    name: String!
    exchanges: [String]!
  ): UnsignedTransaction

  """
  Executes the "beginSetup" transaction with the given gas price per unit.
  """
  executeFundSetupBegin(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
  ): String

  """
  Estimates the number of gas units required for a fund setup step transaction.
  """
  estimateFundSetupStep(
    "The step in the fund factory process."
    step: FundSetupStepEnum!
  ): UnsignedTransaction

  """
  Executes a fund setup step transaction with the given gas price per unit.
  """
  executeFundSetupStep(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
    "The step in the fund factory process."
    step: FundSetupStepEnum!
  ): Boolean

  """
  Estimates the number of gas units required for the "completeSetup" transaction.
  """
  estimateFundSetupComplete: UnsignedTransaction

  """
  Executes the "completeSetup" transaction with the given gas price per unit.
  """
  executeFundSetupComplete(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
  ): String

  """
  Estimates the number of gas units required for the "request investment" transaction.
  """
  estimateRequestInvestment(
    fundAddress: String!
    investmentAmount: String!
  ): UnsignedTransaction

  """
  Executes the "request investment" transaction with the given gas price per unit.
  """
  executeRequestInvestment(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
    fundAddress: String!
  ): Boolean

  """
  Estimates the number of gas units required for the "execute request" transaction.
  """
  estimateExecuteRequest(
    fundAddress: String!
  ): UnsignedTransaction

  """
  Executes the "execute request" transaction with the given gas price per unit.
  """
  executeExecuteRequest(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
    fundAddress: String!
  ): Boolean

  """
  Estimates the number of gas units required for the "approve transfer" transaction.
  """
  estimateApproveTransfer(
    fundAddress: String!
    investmentAmount: String!
  ): UnsignedTransaction

  """
  Executes the "execute request" transaction with the given gas price per unit.
  """
  executeShutDownFund(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
    fundAddress: String!
  ): Boolean

  """
  Estimates the number of gas units required for the "approve transfer" transaction.
  """
  estimateShutDownFund(
    fundAddress: String!
  ): UnsignedTransaction

  """
  Executes the "approve transfer" transaction with the given gas price per unit.
  """
  executeApproveTransfer(
    "Unsigned transaction data."
    unsigned: UnsignedTransactionInput!
    fundAddress: String!
    investmentAmount: String!
  ): Boolean

  """
  Export the currently active wallet in its encrypted form.
  """
  exportWallet(
    "The password for decrypting the wallet."
    password: String!
  ): String @insecure

  """
  Log out of the current wallet and delete its encrypted representation
  from local storage. This requires the user to either re-upload the
  encrypted wallet or restore it from its mnemonic when attempting to
  log in again.
  """
  deleteWallet: Boolean! @insecure

  """
  Log in to a previously stored wallet. Returns a list of possible account
  addresses from the wallet.
  """
  loginWallet(
    "The password for decrypting the wallet."
    password: String!
  ): [String] @insecure

  """
  Import and log in to wallet using a wallet JSON. Within the native app
  environment, this will cause the encrypted wallet to be stored locally
  for future use.
  """
  importWallet(
    "The encrypted wallet."
    wallet: String!
    "The password for decrypting the wallet."
    password: String!
  ): [String] @insecure

  """
  Restore and login to a wallet using a mnemonic. Within the native app
  environment,this will cause the encrypted wallet to be stored locally
  for future use.
  """
  restoreWallet(
    "The mnemonic to restore the wallet with."
    mnemonic: String!
    "The password for decrypting the wallet."
    password: String!
  ): [String] @insecure

  """
  Randomly generate a new mnemonic phrase.
  """
  generateMnemonic: String @insecure
}

type Subscription {
  currentBlock: String
  nodeSynced: Boolean
  priceFeedUp: Boolean
  peerCount: String
  balance(symbol: SymbolEnum!, address: String): Quantity
}

schema {
  query: Query
  subscription: Subscription
  mutation: Mutation
}
