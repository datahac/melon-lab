scalar DateTime
scalar Quantity
scalar Symbol

enum ExchangeEnum {
  RADAR_RELAY
  OASIS_DEX
  ERC_DEX
  KYBER_NETWORK
}

enum TokenEnum {
  WETH
  ETH
  MLN
}

enum ProviderEnum {
  INJECTED
  LOCAL
  HOSTED
  CUSTOM
  NONE
}

type Wallet {
  accountAddress: String
  privateKey: String
  encryptedWallet: String
}

type Ranking {
  rank: Int
  address: String!
  name: String!
  inception: DateTime!
  fund: Fund
  sharePrice: String!
}

type Fund {
  rank: Int
  address: String!
  name: String!
  inception: DateTime!
  gav: String!
  nav: String!
  owner: String
  modules: [String]
  holdings: [Holding]
  sharePrice: String!
  totalSupply: String
  personalStake(investor: String!): String
  managementReward: String
  performanceReward: String
  unclaimedRewards: String
  rewardsShareQuantity: String
  subscriptionAllowed: Boolean
  redemptionAllowed: Boolean
}

type Holding {
  symbol: String!
  balance: String!
  price: String!
  fraction: String!
}

type HowMuchOfAsset {
  symbol: Symbol!
  howMuch: String!
}

type Trade {
  price: String
  quantity: String
  timestamp: String
  type: String
}

interface Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  exchangeContractAddress: String
  exchange: String
}

type ZeroExOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  expiration: String
  salt: String!
  makerFee: String!
  takerFee: String!
  signature: Signature
  feeRecipient: String
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type OasisDexOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  id: String!
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type Orderbook {
  allOrders: [Order]
  sellEntries: [OrderbookEntry]
  buyEntries: [OrderbookEntry]
  totalBuyVolume: Quantity
  totalSellVolume: Quantity
}

type OrderbookEntry {
  volume: Quantity
  order: Order
}

type Signature {
  r: String!
  s: String!
  v: Int!
}

type Status {
  nodeSyncing: Boolean!
  blockOverdue: Boolean!
  priceFeedUp: Boolean!
}

type Config {
  canonicalPriceFeedAddress: String!
  competitionComplianceAddress: String!
  onlyManagerCompetitionAddress: String!
}

type Query {
  wallet: Wallet
  config: Config!
  status: Status!
  network: String!
  provider: String!
  block: String
  mnemonic: String
  balance(token: TokenEnum!, address: String!): String
  price(symbol: Symbol!): String
  fund(address: String!): Fund
  funds(addresses: [String]): [Fund]
  rankings: [Ranking]
  totalFunds: Int!
  openOrders(address: String!): [Order]
  recentTrades(baseTokenSymbol: String!, quoteTokenSymbol: String!): [Trade]
}

input SignatureInput {
  r: String!
  s: String!
  v: Int!
}

type Mutation {
  cancelOpenOrder(
    orderId: String!
    fundAddress: String!
    makerAssetSymbol: String!
    takerAssetSymbol: String!
  ): [Order]
  createFund(name: String!, signature: SignatureInput!): Fund
  sign(privateKey: String!): Signature
  loadWallet(file: String!, password: String!): Wallet
  restoreWallet(mnemonic: String!, password: String!): Wallet
}

type Subscription {
  state: Status
  block: String
  orderbook(
    baseTokenSymbol: Symbol!
    quoteTokenSymbol: Symbol!
    exchanges: [ExchangeEnum] = [
      "RADAR_RELAY"
      "OASIS_DEX"
      "ERC_DEX"
      "KYBER_NETWORK"
    ]
  ): Orderbook
}

schema {
  query: Query
  subscription: Subscription
  mutation: Mutation
}
