scalar DateTime
scalar Quantity
scalar Symbol

enum ExchangeEnum {
  RADAR_RELAY
  OASIS_DEX
  ERC_DEX
  KYBER_NETWORK
}

enum TokenEnum {
  WETH
  ETH
  MLN
}

enum ProviderEnum {
  INJECTED
  LOCAL
  HOSTED
  CUSTOM
  NONE
}

enum ConfigKeyEnum {
  CANONICAL_PRICE_FEED_ADDRESS
  COMPETITION_COMPLIANCE_ADDRESS
  ONLY_MANAGER_COMPETITION_ADDRESS
  NO_COMPLIANCE_ADDRESS
  MATCHING_MARKET_ADDRESS
  MATCHING_MARKET_ADAPTER
  ZERO_EX_V1_ADDRESS
  ZERO_EX_V1_ADAPTER_ADDRESS
  RANKING_ADDRESS
  RISK_MANAGEMENT_ADDRESS
  VERSION_ADDRESS
  GOVERNANCE_ADDRESS
  OLYMPIAD_ADDRESS
  KYBER_NETWORK_ADDRESS
  KYBER_ADAPTER
}

type Wallet {
  accountAddress: String
  privateKey: String
  encryptedWallet: String
}

type Ranking {
  rank: Int
  address: String!
  name: String!
  inception: DateTime!
  fund: Fund
  sharePrice: String!
}

type NewFund {
  address: String
  name: String
  inception: DateTime
  owner: String
  modules: [String]
}

type Fund {
  rank: Int
  address: String!
  name: String!
  inception: DateTime!
  gav: String!
  nav: String!
  owner: String
  modules: [String]
  holdings: [Holding]
  sharePrice: String!
  totalSupply: String
  personalStake(investor: String!): String
  managementReward: String
  performanceReward: String
  unclaimedRewards: String
  rewardsShareQuantity: String
  subscriptionAllowed: Boolean
  redemptionAllowed: Boolean
}

type Holding {
  symbol: String!
  balance: String!
  price: String!
  fraction: String!
}

type HowMuchOfAsset {
  symbol: Symbol!
  howMuch: String!
}

type Trade {
  price: String
  quantity: String
  timestamp: String
  type: String
}

interface Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  exchangeContractAddress: String
  exchange: String
}

type ZeroExOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  expiration: String
  salt: String!
  makerFee: String!
  takerFee: String!
  signature: Signature
  feeRecipient: String
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type OasisDexOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  id: String!
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type Orderbook {
  allOrders: [Order]
  sellEntries: [OrderbookEntry]
  buyEntries: [OrderbookEntry]
  totalBuyVolume: Quantity
  totalSellVolume: Quantity
}

type OrderbookEntry {
  volume: Quantity
  order: Order
}

type Signature {
  r: String!
  s: String!
  v: Int!
}

type Query {
  mnemonic: String
  network: String
  provider: String
  currentBlock: String
  nodeSynced: Boolean
  priceFeedUp: Boolean
  peerCount: String
  versionConfig(key: ConfigKeyEnum!): String
  totalFunds: Int
  balance(token: TokenEnum!, address: String!): String
  price(symbol: Symbol!): String
  wallet: Wallet
  fund(address: String!): Fund
  funds(addresses: [String]): [Fund]
  rankings: [Ranking]

  # TODO: Move this to the Fund type.
  openOrders(address: String!): [Order]
  recentTrades(baseTokenSymbol: String!, quoteTokenSymbol: String!): [Trade]

  # TODO: Make this return a Fund type.
  usersFund(address: String!): String
}

type Mutation {
  cancelOpenOrder(
    orderId: String!
    fundAddress: String!
    makerAssetSymbol: String!
    takerAssetSymbol: String!
  ): [Order]
  createFund(name: String!, signed: Boolean!, privateKey: String!): NewFund
  deleteWallet: Boolean!
  decryptWallet(wallet: String!, password: String!): Wallet
  restoreWallet(mnemonic: String!, password: String!): Wallet
}

type Subscription {
  network: String
  provider: String
  currentBlock: String
  nodeSynced: Boolean
  priceFeedUp: Boolean
  peerCount: String
  versionConfig(key: ConfigKeyEnum!): String
  totalFunds: Int
  rankings: [Ranking]
  balance(token: TokenEnum!, address: String!): String
  orderbook(
    baseTokenSymbol: Symbol!
    quoteTokenSymbol: Symbol!
    exchanges: [ExchangeEnum] = [
      "RADAR_RELAY"
      "OASIS_DEX"
      "ERC_DEX"
      "KYBER_NETWORK"
    ]
  ): Orderbook
}

schema {
  query: Query
  subscription: Subscription
  mutation: Mutation
}
