# Fields that are only safe within the native app environment and are blocked
# from execution in the hosted / web environment.
directive @insecure on FIELD_DEFINITION

scalar Json
scalar DateTime

enum ExchangeEnum {
  RADAR_RELAY
  OASIS_DEX
  ERC_DEX
  KYBER_NETWORK
}

enum ExchangeContractEnum {
  ZERO_EX_EXCHANGE
  KYBER_NETWORK_PROXY
  MATCHING_MARKET
}

enum TokenEnum {
  WETH
  ETH
  MLN
}

enum ProviderEnum {
  INJECTED
  LOCAL
  HOSTED
  CUSTOM
  NONE
}

enum ConfigKeyEnum {
  CANONICAL_PRICE_FEED_ADDRESS
  COMPETITION_COMPLIANCE_ADDRESS
  ONLY_MANAGER_COMPETITION_ADDRESS
  NO_COMPLIANCE_ADDRESS
  MATCHING_MARKET_ADDRESS
  MATCHING_MARKET_ADAPTER
  ZERO_EX_V1_ADDRESS
  ZERO_EX_V1_ADAPTER_ADDRESS
  RANKING_ADDRESS
  RISK_MANAGEMENT_ADDRESS
  VERSION_ADDRESS
  GOVERNANCE_ADDRESS
  OLYMPIAD_ADDRESS
  KYBER_NETWORK_ADDRESS
  KYBER_ADAPTER
}

type Ranking {
  rank: Int
  address: String!
  name: String!
  inception: DateTime!
  fund: Fund
  sharePrice: String!
}

type Fund {
  rank: Int
  address: String!
  name: String!
  inception: DateTime!
  gav: String!
  nav: String!
  owner: String
  modules: [String]
  holdings: [Holding]
  sharePrice: String!
  totalSupply: String
  personalStake(investor: String!): String
  managementReward: String
  performanceReward: String
  unclaimedRewards: String
  rewardsShareQuantity: String
  subscriptionAllowed: Boolean
  redemptionAllowed: Boolean
}

type Holding {
  symbol: String!
  balance: String!
  price: String!
  fraction: String!
}

type HowMuchOfAsset {
  symbol: String!
  howMuch: String!
}

type Trade {
  price: String
  quantity: String
  timestamp: String
  type: String
}

interface Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  exchangeContractAddress: String
  exchange: String
}

type ZeroExOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  expiration: String
  salt: String!
  makerFee: String!
  takerFee: String!
  signature: Signature
  feeRecipient: String
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type OasisDexOrder implements Order {
  maker: String
  taker: String
  isActive: Boolean!
  type: String!
  buy: HowMuchOfAsset!
  sell: HowMuchOfAsset!
  price: String!
  id: String!
  timestamp: DateTime
  exchange: String
  exchangeContractAddress: String
}

type Orderbook {
  allOrders: [Order]
  sellEntries: [OrderbookEntry]
  buyEntries: [OrderbookEntry]
  totalBuyVolume: String
  totalSellVolume: String
}

type OrderbookEntry {
  volume: String
  order: Order
}

type Signature {
  r: String!
  s: String!
  v: Int!
}

type Exchange {
  value: String
  text: String
}

type Query {
  defaultAccount: String @insecure
  allAccounts: [String] @insecure
  hasStoredWallet: Boolean @insecure

  network: String
  provider: String
  currentBlock: String
  nodeSynced: Boolean
  priceFeedUp: Boolean
  peerCount: String
  versionConfig(key: ConfigKeyEnum!): String
  totalFunds: Int
  balance(token: TokenEnum!, address: String!): String
  price(symbol: String!): String
  fund(address: String!): Fund
  funds(addresses: [String]): [Fund]
  rankings: [Ranking]
  associatedFund(address: String!): Fund
  availableExchanges: [Exchange]

  # TODO: Move this to the Fund type.
  openOrders(address: String!): [Order]
  recentTrades(baseTokenSymbol: String!, quoteTokenSymbol: String!): [Trade]
}

type Mutation {
  cancelOpenOrder(
    orderId: String!
    fundAddress: String!
    makerAssetSymbol: String!
    takerAssetSymbol: String!
  ): [Order]

  prepareSetupFund(exchanges: [ExchangeContractEnum]!, name: String!): Json
  executeSetupFund(transaction: Json!): String

  """
  Export the currently active wallet in its encrypted form.
  """
  exportWallet(
    "The password for decrypting the wallet."
    password: String!
  ): String @insecure

  """
  Log out of the current wallet and delete its encrypted representation
  from local storage. This requires the user to either re-upload the
  encrypted wallet or restore it from its mnemonic when attempting to
  log in again.
  """
  deleteWallet: Boolean! @insecure

  """
  Log in to a previously stored wallet. Returns a list of possible account
  addresses from the wallet.
  """
  loginWallet(
    "The password for decrypting the wallet."
    password: String!
  ): [String] @insecure

  """
  Import and log in to wallet using a wallet JSON. Within the native app
  environment, this will cause the encrypted wallet to be stored locally
  for future use.
  """
  importWallet(
    "The encrypted wallet."
    wallet: String!
    "The password for decrypting the wallet."
    password: String!
  ): [String] @insecure

  """
  Restore and login to a wallet using a mnemonic. Within the native app
  environment,this will cause the encrypted wallet to be stored locally
  for future use.
  """
  restoreWallet(
    "The mnemonic to restore the wallet with."
    mnemonic: String!
    "The password for decrypting the wallet."
    password: String!
  ): [String] @insecure

  """
  Randomly generate a new mnemonic phrase.
  """
  generateMnemonic: String @insecure
}

type Subscription {
  network: String
  provider: String
  currentBlock: String
  nodeSynced: Boolean
  priceFeedUp: Boolean
  peerCount: String
  versionConfig(key: ConfigKeyEnum!): String
  totalFunds: Int
  rankings: [Ranking]
  balance(token: TokenEnum!, address: String!): String
  orderbook(
    baseTokenSymbol: String!
    quoteTokenSymbol: String!
    exchanges: [ExchangeEnum] = [
      "RADAR_RELAY"
      "OASIS_DEX"
      "ERC_DEX"
      "KYBER_NETWORK"
    ]
  ): Orderbook
}

schema {
  query: Query
  subscription: Subscription
  mutation: Mutation
}
